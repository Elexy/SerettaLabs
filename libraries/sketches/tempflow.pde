// Control and monitor the temperature for a reflow grill
// see http://news.jeelabs.org/2009/06/15/reflow-experimentation/
// and http://news.jeelabs.org/2009/07/13/my-first-reflow/
//
// 2009-07-10 <jcw@equi4.com> http://opensource.org/licenses/mit-license.php
// $Id: tempflow.pde 6001 2010-09-09 22:49:39Z jcw $

#include <RF12.h>
#include <NewSoftSerial.h>
#include "WProgram.h"
#include "millitimer.h"
#include <avr/eeprom.h>
#include <util/parity.h>

#define EEPROM_ADDR ((byte*) 150)
#define BEEP_PIN 	5
#define RED_LED		6
#define GREEN_LED	16
#define HOUSE_CODE	0x1234
#define OVERSHOOT	30

enum { OFF, PREHEAT, SOAK, DWELL, REFLOW, COOL };
#define PHASES " PSDRC"

// configuration settings, 10 of these are stored in EEPROM
typedef struct {
	int preheat, soak, reflow, duration, maxtime, increment;
} Config;

NewSoftSerial lcd (14, 4);

class BothSerial : public Print {
public:
	BothSerial () {}
	virtual void write (byte c) { Serial.write(c); lcd.print(c); }
};

BothSerial both;

// Utility class to reliably detect a button press on a digital I/O line.
// The button must be wired to short to ground, works with internal pull-up.

class Button {
	byte state, pin, last;
	MilliTimer debounce;
public:
	Button (byte p) : pin (p), state (0xFF), last (0) {
		pinMode(pin, INPUT);
		digitalWrite(pin, 1); // pull-up
	}
	byte pushed () {
		byte result = 0;
		// only check every 10 ms, 8x 0's means down, 8x 1's means up
		// every other combination is ignored
		if (debounce.poll(10)) {
			state <<= 1;
			state |= digitalRead(pin);
			if (state == 0xFF)
				last = 0;
			if (state == 0x00) {
				// if down and last state was up, then we have a new press
				result = last == 0;
				last = 1;
			}
		}
		return result;
	}
};

byte onOff; // current state of the power relay
word value; // serial input value
MilliTimer seconds; // everything happens once a second
byte currConf, phase;
Config config; // current configuration
float delta, temp, prevtemp, target, cutoff;
long start; // time when current phase was started, in milliseconds
Button black (7), white (17);

// this code copied from the fs20demo sketch

static void sendBits(uint16_t data, uint8_t bits) {
    if (bits == 8) {
        ++bits;
        data = (data << 1) | parity_even_bit(data);
    }
    for (uint16_t mask = bit(bits-1); mask != 0; mask >>= 1) {
        int width = data & mask ? 575 : 375; // 25 usec is approx overhead
        rf12_onOff(1);
        delayMicroseconds(width);
        rf12_onOff(0);
        delayMicroseconds(width);
    }
}

static void fs20cmd(uint16_t house, uint8_t addr, uint8_t cmd) {
	uint8_t sum = 6 + (house >> 8) + house + addr + cmd;
	for (uint8_t i = 0; i < 3; ++i) {
		sendBits(1, 13);
		sendBits(house >> 8, 8);
		sendBits(house, 8);
		sendBits(addr, 8);
		sendBits(cmd, 8);
		sendBits(sum, 8);
		sendBits(0, 1);
		delay(10);
	}
}

static void lcdPos (byte y, byte x, byte clr) {
	lcd.print("?y"); lcd.print((int) y);
	lcd.print("?x"); lcd.print((int) x/10); lcd.print((int) x%10);
	if (clr)
		lcd.print("?l");
}

// emit a short beep - 0.5 sec @ 4 KHz seems to give the clearest sound
static void beep () {
	for (int i = 0; i < 2000; ++i) {
		digitalWrite(BEEP_PIN, 1);
		delayMicroseconds(125);
		digitalWrite(BEEP_PIN, 0);
		delayMicroseconds(125);
	}
}

// load configuration from EEPROM, or use default if not set yet
static byte loadConfig (byte curr) {
	if (curr > 10)
		curr = eeprom_read_byte(EEPROM_ADDR);
	if (curr >= 10)
		curr = 0;
		
	byte* offset = EEPROM_ADDR + 1 + curr * sizeof config;
	for (byte i = 0; i < sizeof config; ++i)
		((byte*) &config)[i] = eeprom_read_byte(offset+i);
		
	if (config.preheat < 0) {
		config.preheat = 125;
		config.soak = 170;
		config.reflow = 220;
		config.duration = 30;
		config.maxtime = 20;
		config.increment = 40;
	}
	
	return curr;
}

// save current configuration
static void saveConfig (byte curr) {
	eeprom_write_byte(EEPROM_ADDR, curr);
	
	byte* offset = EEPROM_ADDR + 1 + curr * sizeof config;
	for (byte i = 0; i < sizeof config; ++i)
		eeprom_write_byte(offset+i, ((byte*) &config)[i]);
}

// display current configuration on lcd and serial port
static void showConfig () {
	lcdPos(0, 0, 1);
	both.print("Reflow1 #"); both.print((int) currConf);
	both.print(": i"); both.print(config.increment);
	both.print(" p"); both.print(config.preheat);
	both.print(" d"); both.print(config.duration);
	both.print(" s"); both.print(config.soak);
	both.print(" r"); both.print(config.reflow);
	both.print(" m"); both.print(config.maxtime);
	Serial.println();
}

// this polynomial fit was generated by zunzun.com
static double adc2temp (double x_in) {
	double a = 5.1682354188330737E+02;
	double b = -4.9597531799503596E+00;
	double c = 3.0869928551063255E-02;
	double d = -1.0890208056026828E-04;
	double e = 2.2199086797539969E-07;
	double f = -2.5984591161006065E-10;
	double g = 1.6204437739964905E-13;
	double h = -4.1733491306188278E-17;

	double temp = h;
	temp = temp * x_in + g;
	temp = temp * x_in + f;
	temp = temp * x_in + e;
	temp = temp * x_in + d;
	temp = temp * x_in + c;
	temp = temp * x_in + b;
	temp = temp * x_in + a;
	return temp;
}

static void showHelp () {
	Serial.println("Go On Use Incr Preheat Duration Soak Reflow Maxtime");
}

// turn power for the grill on or off
static void power (byte on) {
	if (on != onOff) {
		onOff = on;
		fs20cmd(0x1234, 1, on ? 17 : 0);
		digitalWrite(RED_LED, on);
	}
}

// change to a new pahes in the temperature profile
static void setPhase (byte p) {
	if (p != phase) {
		phase = p;
		start = millis();
		if (phase == OFF) {
			power(0);
			target = 0;
		}
	}
}

// how many seconds have elapsed in the current phase?
static word elapsed () {
	return (millis() - start) / 1000;
}

// interpret interactive input from the serial line
static void processCommand () {
    char c = Serial.read();
    if ('0' <= c && c <= '9')
        value = 10 * value + c - '0';
    else if ('a' <= c && c <='z') {
        Serial.print("> ");
        Serial.print((int) value);
        Serial.println(c);
        switch (c) {
            default:
                showHelp();
                break;
			case 'g': // go
				setPhase(PREHEAT);
				break;
			case 'o': // <n> on
				power(value != 0);
				break;
			case 'u': // <n> use config
				currConf = loadConfig(value);
				break;
			case 'p': // <n> preheat temp, degrees
				config.preheat = value;
				break;
			case 's': // <n> soak end temp, degrees
				config.soak = value;
				break;
			case 'r': // <n> reflow temp, degrees
				config.reflow = value;
				break;
			case 'd': // <n> soak duration, seconds
				config.duration = value;
				break;
			case 'm': // <n> max time reflow, seconds
				config.maxtime = value;
				break;
			case 'i': // <n> increment, 0.01 degrees/sec
				config.increment = value;
				break;
        }
		showConfig();
           saveConfig(currConf);
        value = 0;
    } else if (c > ' ')
        showHelp();
}

// main reflow algorithm, called once a second
static void reflow () {
	if (temp < 0) {
		power(0);
		return; // malfunction
	}
		
	if (delta > config.increment * 0.1) {
		power(0);
		return;
	}
	
	switch (phase) {
		case PREHEAT:
			target = config.preheat;
			break;
		case SOAK:
			target = map(elapsed(), 0, config.duration,
										config.preheat, config.soak);
			if (target > config.soak)
				target = config.soak;
			break;
		case DWELL:
		case REFLOW:
			target = config.reflow;
			break;
		default:
			target = 0;
			break;
	}

	cutoff = target - delta * OVERSHOOT;
	power(temp < cutoff);
	
	switch (phase) {
		case PREHEAT:
			if (temp >= target)
				setPhase(SOAK);
			break;
		case SOAK:
			if (temp >= target && elapsed() >= config.duration)
				setPhase(DWELL);
			break;
		case DWELL:
			if (temp >= target)
				setPhase(REFLOW);
			break;
		case REFLOW:
			if (elapsed() >= config.maxtime)
				setPhase(COOL);
			break;
		case COOL:
			if (temp < 50)
				setPhase(OFF);
			break;
	}
}

void setup() {
	Serial.begin(57600);
	Serial.println("\n[tempflow]");
	rf12_initialize(0, RF12_868MHZ);
	pinMode(BEEP_PIN, OUTPUT);
	pinMode(GREEN_LED, OUTPUT);
	pinMode(RED_LED, OUTPUT);
	
	delay(5000);
	lcd.begin(9600);
	lcd.print("?B80"); delay(100);	// backlight intensity
	lcd.print("?c0"); delay(100);	// cursor off
	lcd.print("?f"); delay(100);	// clear screen
	
	onOff = 1; // force mismatch
	power(0);
	
	currConf = loadConfig(-1);
	showConfig();
}

void loop() {
	if (Serial.available()) {
		if (phase == OFF)
			processCommand();
		else {
			setPhase(OFF);
			power(0);
			delay(1000);
			Serial.flush();
		}
	}

	if (black.pushed()) {
		currConf = loadConfig((currConf + 1) % 10);
		showConfig();
	}

    if (white.pushed())
		setPhase(phase == OFF ? PREHEAT : OFF);
	
	if (seconds.poll(1000)) {
		int t = analogRead(1);
		prevtemp = temp;
		temp = adc2temp(t);
		delta = (7 * delta + temp - prevtemp) / 8;
		
		lcdPos(2, 0, 1);
		both.print('e');
		both.print(elapsed());
		both.print(" t");
		both.print(target);
		both.print(" c");
		both.print(cutoff);
		both.print(' ');
		
		lcdPos(3, 0, 1);
		both.print(PHASES[phase]);
		both.print(" *"[onOff]);
		both.print(" a");
		both.print(t);
		both.print(' ');
		both.print((int) (temp + 0.5));
		both.print("C ");
		both.print(delta);
		Serial.println();

		digitalWrite(GREEN_LED, phase == OFF); // inverted logic, tied to +3V
		
		if (phase != OFF)
			reflow();
		
		if (phase == COOL && elapsed() < 5)
			beep();
	}
}
